import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.script.GhidraScript;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileOptions;
import ghidra.util.task.ConsoleTaskMonitor;
import ghidra.program.model.data.Enum;
import ghidra.app.decompiler.parallel.DecompilerCallback;
import ghidra.app.decompiler.parallel.ParallelDecompiler;
import ghidra.util.task.TaskMonitor;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.DecompInterface;
import ghidra.program.model.listing.Function;
import ghidra.app.decompiler.parallel.DecompileConfigurer;
import ghidra.app.decompiler.DecompiledFunction;

public class ExportTypeConversion extends GhidraScript {

    @Override
    protected void run() throws Exception {

        File outputFile = new File(currentProgram.getExecutablePath()).getParentFile();
        File f = new File(outputFile, "TypeConversion.c");

        try (FileWriter writer = new FileWriter(f)) {
            writer.write("// Auto-generated by Ghidra Script DO NOT MODIFY\n\n");
            writer.write("#include <stdint.h>\n");
            writer.write(
                "#if __has_include(<Python.h>)\n" +
                "    #define BUILDING_PYTHON_EXTENSION 1\n" +
                "#endif\n\n" +
                "#ifdef BUILDING_PYTHON_EXTENSION\n" +
                "#define PY_SSIZE_T_CLEAN\n" +
                "#include <Python.h>\n" +
                "#endif\n\n"
            );

            var dtm = currentProgram.getDataTypeManager();
            var allDataTypes = dtm.getAllDataTypes();

            while (allDataTypes.hasNext()) {
				var dt = allDataTypes.next();
                if (dt.getName().equals("Protocol__Enum") && dt instanceof Enum) {
                    Enum enumType = (Enum) dt;
                    writer.write("typedef enum " + enumType.getName() + " {\n");
                    var names = enumType.getNames();
                    var values = enumType.getValues();
                    for (int i = 0; i < names.length; i++) {
                        writer.write("    " + names[i] + " = " + values[i] + ",\n");
                    }
                    writer.write("} " + enumType.getName() + ";\n\n");
                    break;
                }
            }
			ArrayList<Function> matchingFunctions = new ArrayList<>();

			for (var func : currentProgram.getFunctionManager().getFunctions(true)) {
				if (func.getName(true).startsWith("MX::NetworkProtocol::ProtocolConverter::ProtocolConverter_typeConversion")) {
					matchingFunctions.add(func);
					if (matchingFunctions.size() >= 99) {
						break;
					}
				}
			}
			
			var tMonitor = new ConsoleTaskMonitor();
			tMonitor.setMaximum(99);
			tMonitor.setMessage("Decompiling C");
			DecompilerCallback<DecompiledFunction> callback = new DecompilerCallback<>(currentProgram, new DecompileConfigurer(){ public void configure(DecompInterface decompiler) {}}) {
					@Override
					public DecompiledFunction process(DecompileResults results, TaskMonitor monitor)
							throws Exception {
						monitor.incrementProgress();
						return results.getDecompiledFunction();
					}
				};
			long startTime = System.currentTimeMillis();
			var results = ParallelDecompiler.decompileFunctions(callback, matchingFunctions, tMonitor);
			System.out.printf("Decompiled %d functions, took %d ms\n", results.size(), System.currentTimeMillis() - startTime);
			
			results.sort((f1, f2) -> {
				int n1 = Integer.parseInt(f1.getSignature().replaceAll(".*typeConversion(\\d+).*", "$1"));
				int n2 = Integer.parseInt(f2.getSignature().replaceAll(".*typeConversion(\\d+).*", "$1"));
				return Integer.compare(n1, n2);
			});
			for (DecompiledFunction func : results) {
				writer.write(func.getC().replace("::", "_").replace("uint ", "uint32_t ").replace("(ProtocolConverter *this,Protocol__Enum protocol,MethodInfo *method)", "(Protocol__Enum protocol)"));
			}
			
			writer.write("int32_t MX_NetworkProtocol_ProtocolConverter_ProtocolConverter_TypeConversion(uint32_t crc, Protocol__Enum protocol) {\n");
			writer.write("    switch (crc % 99) {\n");

			for (int i = 0; i < results.size(); i++) {
				writer.write(String.format(
					"        case %d: return MX_NetworkProtocol_ProtocolConverter_ProtocolConverter_typeConversion%d(protocol);\n",
					i, i));
			}
			writer.write("    }\n");
			writer.write("}\n\n");
			
			writer.write("#if defined(_WIN32) || defined(__CYGWIN__)\n");
			writer.write("  #define EXPORT __declspec(dllexport)\n");
			writer.write("#else\n");
			writer.write("  #define EXPORT __attribute__((visibility(\"default\")))\n");
			writer.write("#endif\n\n");

			writer.write("EXPORT int32_t TypeConversion(uint32_t crc, int protocol)\n");
			writer.write("{\n");
			writer.write("    return MX_NetworkProtocol_ProtocolConverter_ProtocolConverter_TypeConversion(crc, (Protocol__Enum)protocol);\n");
			writer.write("}\n\n");

			writer.write("#ifdef BUILDING_PYTHON_EXTENSION\n\n");

			writer.write("static PyObject* py_TypeConversion(PyObject* self, PyObject* args) {\n");
			writer.write("    uint32_t crc;\n");
			writer.write("    int protocol;\n\n");
			writer.write("    if (!PyArg_ParseTuple(args, \"Ii\", &crc, &protocol)) {\n");
			writer.write("        return NULL;\n");
			writer.write("    }\n\n");
			writer.write("    int32_t result = TypeConversion(crc, protocol);\n\n");
			writer.write("    return PyLong_FromLong(result);\n");
			writer.write("}\n\n");

			writer.write("static PyMethodDef TypeConversionMethods[] = {\n");
			writer.write("    {\"TypeConversion\", py_TypeConversion, METH_VARARGS,\n");
			writer.write("     \"Convert (crc, protocol) using MX_NetworkProtocol converter.\"},\n");
			writer.write("    {NULL, NULL, 0, NULL}\n");
			writer.write("};\n\n");

			writer.write("static struct PyModuleDef TypeConversionModule = {\n");
			writer.write("    PyModuleDef_HEAD_INIT,\n");
			writer.write("    \"TypeConversion\",\n");
			writer.write("    NULL,\n");
			writer.write("    -1,\n");
			writer.write("    TypeConversionMethods\n");
			writer.write("};\n\n");

			writer.write("PyMODINIT_FUNC PyInit_TypeConversion(void) {\n");
			writer.write("    return PyModule_Create(&TypeConversionModule);\n");
			writer.write("}\n\n");

			writer.write("#endif\n");
        } catch (IOException e) {
            printerr("Failed to write output: " + e.getMessage());
        }
    }
}
